" Vim plugin: JDOX_CPP for automatic generation of javadoc compatibile 
" function comments in .cpp files
" Last Change: Sat Oct 21 19:48:14 CEST 2006
" Maintainer: Pawel Prokop <pablo@wizard.ae.krakow.pl>
" Version: 1.00pre1
" License: GNU General Public License
" Usage: press: \d (backslash d) when cursor is on name of function
"        definition to comment. Jdox works only with function definitions
"        currently.
" Contact: if you have any suggestions, advices, bugs or just want to
"          feedback mail to author with 'jdox' in subject
" TODO: Test*Test
"       STL parameters, return types support
"========================================================
" ensure version is >=700
if v:version <700
	finish
endif
"========================================================
" CONFIGURATION
"
" comma separated tags that will be displayed in comment
" NOTE: @param and @return body is generated by plugin
" Other tags may be set default @see s:jdox_default variable
"
" Other portable tags:
" @throws @exception @author @version @see @since @serial
" @serialField @serialData @deprecated {@link}
let s:jdox_tags = ["@author","@param","@return","@version"]

" For tags such as @author, @version, @since it may sense to
" store default values in config (vim's dictionary format)
" format: '@tag_name': 'default value string'
let s:jdox_default = { '@author': 'Pawel Prokop <pablo@wizard.ae.krakow.pl>', '@version': '1.0', '@since': '1.0' }

" ~CONFIGURATION	
"========================================================

"========================================================
" JDOX BODY
"
" ensure that the plugin is loaded only once
if exists("loaded_doxy_cpp_plugin")
	finish
endif
let loaded_doxy_cpp_plugin = 1

" Saving value of cpoptions, and then setting to vim default
let s:save_cpo = &cpo
set cpo&vim

" mapping
" \d
if !hasmapto('<Plug>jdox_cpp_plugin')
	map <unique> <Leader>d <Plug>jdox_cpp_plugin
endif


"========================================================
"Function returns smaller point, if one is [0,0] returns another
"@param c1 first comparision point
"@param c2 second comparision point
"@return two element list
function s:jdox_get_smaller_pos(c1, c2)

   if a:c1 == [0,0]
		return a:c2
 	elseif a:c2 == [0,0]
	  	return a:c1
	endif

	if a:c1[0] < a:c2[0]
		return a:c1
	elseif a:c1[0] == a:c2[0]
		if a:c1[1] < a:c2[1]
			return a:c1
	 	else
			return a:c2
 		endif	
 	else		
		return a:c2
 	endif		

endfunction
"========================================================

"========================================================
"Function returns beginning of the comment if cursor is 
"in comment [0,0] elseware
"@return two element list
function s:jdox_is_in_comment()

	" check we are between /* and */
	let a:c1 = searchpairpos('/\*','','\*/','bcWn')
	
	" check left of us is // <- the comment beginning
	let a:c2 = searchpos('//','bcWn', getpos(".")[1])

	:return s:jdox_get_smaller_pos( a:c1 , a:c2 )

endfunction
"========================================================

"========================================================
"Function jumps out of comment i given direction
"@param dir direction of jumping: may be '' forward
"or 'b' backward
function s:jump_out_from_comment(dir)
"	:echo "jump_out_from_comment"

	let a:c1 = searchpairpos('/\*','.*','\*/', 'Wc' . a:dir )
"	:echo a:c1
	if a:dir == 'b'
		:normal b
 	else
		:normal w
	endif	

"	:echo "jumped out: "
"	:echo getpos('.')

endfunction
"========================================================

"========================================================
"Function moves cursor left, out of comment
function s:jump_out_from_comment_left()
	:call searchpos('/\*', 'Wcb')
endfunction	
"========================================================

"========================================================
"Function moves cursor right, out of comment
function s:jump_out_from_comment_right()
	:call searchpos('\*/', 'Wc')
endfunction	
"========================================================

"========================================================
" Function obtains type of clicked statement
" @return int value
" 1 = class
" 2 = function - declaration or definition
" 3 = declaration function
" 4 = definition function
" 5 = unknown
function s:obtain_type()

	let a:is_type_obtained = 0

	while a:is_type_obtained == 0

		"is class or function
		"left search for:    class } ; */ // #
		let a:found = searchpos('\<\(class\)\>\|\(}\)\|\(;\)\|\(\*/\)\|\(//\)\|\(#\)', 'bcWp')

		if a:found[2] == 2 "class
			let a:is_type_obtained = 1
		elseif	a:found[2] == 3 " close bracked
			let a:is_type_obtained = 2
		elseif	a:found[2] == 4 " statement_end
			let a:is_type_obtained = 2 
		elseif	a:found[2] == 5 " comment_end 
			:call s:jump_out_from_comment_left()
		elseif	a:found[2] == 6 " comment
			:normal k$
		elseif 	a:found[2] == 7 " firective
	 		let a:is_type_obtained = 2
		endif					

	endwhile

	if a:is_type_obtained == 1
		return a:is_type_obtained
	endif

	" set position at a user click
	:call cursor(s:click[1],s:click[2])
"	:echo getpos('.')

	while a:is_type_obtained == 2
	" got function, so now obtain right side of function name
		let a:found = searchpos('\(/\*\)\|\(;\)\|\({\)\|\(//\)', 'cWp')

		if a:found[2] == 2
		  " got comment
		  :call s:jump_out_from_comment_right()
		elseif a:found[2] == 3
			" semicolon, so declaration				  
			let a:is_type_obtained = 3
		elseif	a:found[2] == 4 
			" scope begin, so definition
			let a:is_type_obtained = 4	  
			"remember position globaly for further use
			let s:end_function_line = a:found
		elseif	a:found[2] == 5
			" comment begin: //
			:normal j0	  
		endif		  
	
	endwhile

	:return a:is_type_obtained

endfunction
"========================================================

"========================================================
"Function seeks for type of function 
"@return list with return type words 
function s:jdox_get_return_type()

	let a:all_tokens = 0
	let a:tokens = []

	while a:all_tokens == 0
"		:let a:found = searchpos('\(\*/\)\|\(;\)\|\(\*\)\|\([a-zA-Z0-9_\[\]]*\)','bcWp')
		:normal b
		:normal yw
		:let a:found = @"

		if a:found =~ '\*/'
			:call s:jump_out_from_comment_left()
		elseif a:found =~ '.*;.*'
			:call reverse(a:tokens)
			:return a:tokens
		elseif a:found == '\*'
			:let s:ret_begin = getpos('.')
			:call add(a:tokens, "*")
		elseif a:found =~ '[a-zA-Z0-9_\[\]&]*'
			if a:found !~ '\n' " not to append empty lines to param list
				:let s:ret_begin = getpos('.')
				:call add(a:tokens, @" )
			endif
		endif
	
	endwhile

endfunction
"========================================================

"========================================================
"Function seeks for parameter names of function
"@return list with parameter names
function s:jdox_get_param_name_list()
		  
	let a:all_tokens = 0
	let a:tokens = []	

	:call cursor(s:end_function_line[0], s:end_function_line[1])

	:call searchpos(')','cbW')
	:normal b

	while a:all_tokens == 0
		:normal yw
		let a:found = @"

		if a:found  =~ "[a-zA-Z0-9]*"
			if a:found !~ ',' && a:found !~ '[\(\)]'
				:call add(a:tokens, a:found)
	 		endif

			let a:seek_coma = searchpos('\(\*/\)\|\(,\)\|\((\)','bcWp')
			if a:seek_coma[2] == 2
				:call s:jump_out_from_comment_left()
				:normal b
	 		elseif a:seek_coma[2] == 4
			 	:call reverse(a:tokens)
				:return a:tokens
			elseif a:seek_coma[2] == 3
				:normal b
	 		endif	

		elseif a:found == '('
			 :call reverse(a:tokens)
			:return a:tokens
		elseif a:found =~ '\*/'
			:call s:jump_out_from_comment_left()
			:normal b
		endif
"		:echo getpos('.')

	endwhile

endfunction
"========================================================

"========================================================
"Display comment over the function definition
function s:jdox_javadoc_deffunc_comment(arguments, return_type)

	let a:comment = "/**\n * Function: " . s:name . "\n"

	for config_param in s:jdox_tags
		if config_param == "@param"
			for param in a:arguments
				let a:comment .= " * @param " . param . " \n"
			endfor
		elseif config_param == "@return"
			let a:comment .= " * @return "
			for param in a:return_type
				let a:comment .= param . ' '
			endfor
			let a:comment .= "\n"
		else
			let a:comment .= " * " . config_param . ' '
			let a:comment .= s:jdox_default[config_param]
	 		let a:comment .= "\n"		
		endif		  
	endfor
	let a:comment .= " */\n"

	let @" = a:comment

	:call cursor(s:ret_begin[1],s:ret_begin[2])
	":echo s:ret_begin
	":echo getpos('.')
	:normal ^P

endfunction
"========================================================

"========================================================
"Function is main function of plugin script
function s:jdox_cpp_header()

	let s:click = getpos('.')

	"program will not work inside comments
	if s:jdox_is_in_comment() != [0,0]
		:echo "Plugin do not work inside comments"
	  :return
	endif

	"function or class name under cursor
	let s:name = expand('<cword>')	

	:call cursor(s:click[1],s:click[2])
	let a:type = s:obtain_type()

	if a:type == 4
		:call cursor(s:click[1],s:click[2])
		:call searchpos('\(\t\)\|\(\ \)\|\(^\)','cbW')
		let a:return_type = s:jdox_get_return_type()

		let a:arguments = s:jdox_get_param_name_list()

		:call s:jdox_javadoc_deffunc_comment(a:arguments, a:return_type)

	endif

	:call cursor(s:click[1],s:click[2])
	:return 

endfunction
"========================================================

noremap <unique> <script> <Plug>jdox_cpp_plugin  <SID>jdox_cpp_header
noremap <SID>jdox_cpp_header :call <SID>jdox_cpp_header()<CR>

" restoring cpoptions
let &cpo=s:save_cpo
